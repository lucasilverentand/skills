const args = Bun.argv.slice(2);

const HELP = `
vulnerability-scan — Scan a Docker image for known CVEs using Trivy or Docker Scout

Usage:
  bun run tools/vulnerability-scan.ts <image> [options]

Arguments:
  <image>  Docker image name or ID to scan

Options:
  --severity <levels>  Filter by severity: CRITICAL,HIGH,MEDIUM,LOW (default: CRITICAL,HIGH)
  --json               Output as JSON instead of plain text
  --help               Show this help message
`.trim();

if (args.includes("--help") || args.length === 0) {
  console.log(HELP);
  process.exit(0);
}

const jsonOutput = args.includes("--json");
const sevIdx = args.indexOf("--severity");
const severity = sevIdx !== -1 && args[sevIdx + 1] ? args[sevIdx + 1] : "CRITICAL,HIGH";
const filteredArgs = args.filter((a) => !a.startsWith("--") && !(sevIdx !== -1 && args[sevIdx + 1] === a));

interface Vulnerability {
  id: string;
  severity: string;
  package: string;
  installedVersion: string;
  fixedVersion: string;
  title: string;
}

interface ScanResult {
  image: string;
  scanner: string;
  vulnerabilities: Vulnerability[];
  summary: Record<string, number>;
}

async function run(cmd: string[]): Promise<{ stdout: string; stderr: string; exitCode: number }> {
  const proc = Bun.spawn(cmd, { stdout: "pipe", stderr: "pipe" });
  const [stdout, stderr] = await Promise.all([
    new Response(proc.stdout).text(),
    new Response(proc.stderr).text(),
  ]);
  const exitCode = await proc.exited;
  return { stdout: stdout.trim(), stderr: stderr.trim(), exitCode };
}

async function checkCommand(cmd: string): Promise<boolean> {
  const result = await run(["which", cmd]);
  return result.exitCode === 0;
}

async function scanWithTrivy(image: string): Promise<ScanResult> {
  const result = await run([
    "trivy", "image", "--format", "json",
    "--severity", severity,
    "--quiet",
    image,
  ]);

  if (result.exitCode !== 0) {
    throw new Error(`Trivy scan failed: ${result.stderr}`);
  }

  const data = JSON.parse(result.stdout);
  const vulnerabilities: Vulnerability[] = [];

  for (const target of data.Results || []) {
    for (const vuln of target.Vulnerabilities || []) {
      vulnerabilities.push({
        id: vuln.VulnerabilityID,
        severity: vuln.Severity,
        package: vuln.PkgName,
        installedVersion: vuln.InstalledVersion || "",
        fixedVersion: vuln.FixedVersion || "not fixed",
        title: vuln.Title || vuln.Description?.slice(0, 100) || "",
      });
    }
  }

  const summary: Record<string, number> = {};
  for (const v of vulnerabilities) {
    summary[v.severity] = (summary[v.severity] || 0) + 1;
  }

  return { image, scanner: "trivy", vulnerabilities, summary };
}

async function scanWithScout(image: string): Promise<ScanResult> {
  const result = await run([
    "docker", "scout", "cves", image,
    "--format", "json",
    "--only-severity", severity.toLowerCase().replace(/,/g, ","),
  ]);

  if (result.exitCode !== 0) {
    throw new Error(`Docker Scout scan failed: ${result.stderr}`);
  }

  // Docker Scout JSON output varies, parse what we can
  let data: any;
  try {
    data = JSON.parse(result.stdout);
  } catch {
    return { image, scanner: "docker-scout", vulnerabilities: [], summary: {} };
  }

  const vulnerabilities: Vulnerability[] = [];
  const vulns = data.vulnerabilities || data.results || [];

  for (const v of vulns) {
    vulnerabilities.push({
      id: v.id || v.cve || "",
      severity: (v.severity || "UNKNOWN").toUpperCase(),
      package: v.package || v.pkgName || "",
      installedVersion: v.version || v.installed || "",
      fixedVersion: v.fixedIn || v.fixedVersion || "not fixed",
      title: v.title || v.description?.slice(0, 100) || "",
    });
  }

  const summary: Record<string, number> = {};
  for (const v of vulnerabilities) {
    summary[v.severity] = (summary[v.severity] || 0) + 1;
  }

  return { image, scanner: "docker-scout", vulnerabilities, summary };
}

async function main() {
  const image = filteredArgs[0];
  if (!image) {
    console.error("Error: missing required <image> argument");
    process.exit(1);
  }

  const hasTrivy = await checkCommand("trivy");
  const hasScout = await checkCommand("docker");

  let result: ScanResult;

  if (hasTrivy) {
    result = await scanWithTrivy(image);
  } else if (hasScout) {
    try {
      result = await scanWithScout(image);
    } catch {
      console.error("Error: neither Trivy nor Docker Scout are available");
      console.error("Install Trivy: brew install trivy");
      process.exit(1);
    }
  } else {
    console.error("Error: no vulnerability scanner found");
    console.error("Install Trivy: brew install trivy");
    process.exit(1);
  }

  if (jsonOutput) {
    console.log(JSON.stringify(result, null, 2));
  } else {
    console.log(`Vulnerability scan: ${result.image} (${result.scanner})\n`);

    if (Object.keys(result.summary).length === 0) {
      console.log("No vulnerabilities found at the selected severity levels.");
      process.exit(0);
    }

    console.log("Summary:");
    for (const [sev, count] of Object.entries(result.summary)) {
      console.log(`  ${sev}: ${count}`);
    }
    console.log();

    // Group by severity
    const grouped: Record<string, Vulnerability[]> = {};
    for (const v of result.vulnerabilities) {
      if (!grouped[v.severity]) grouped[v.severity] = [];
      grouped[v.severity].push(v);
    }

    const order = ["CRITICAL", "HIGH", "MEDIUM", "LOW"];
    for (const sev of order) {
      const vulns = grouped[sev];
      if (!vulns) continue;

      console.log(`${sev} (${vulns.length}):`);
      for (const v of vulns.slice(0, 20)) {
        console.log(`  ${v.id} — ${v.package}@${v.installedVersion}`);
        if (v.title) console.log(`    ${v.title}`);
        console.log(`    Fixed in: ${v.fixedVersion}`);
      }
      if (vulns.length > 20) console.log(`  ... and ${vulns.length - 20} more`);
      console.log();
    }

    const critCount = result.summary["CRITICAL"] || 0;
    if (critCount > 0) {
      console.log(`ACTION REQUIRED: ${critCount} critical vulnerability(ies) found. Upgrade the base image or affected packages.`);
    }
  }

  const hasCritical = (result.summary["CRITICAL"] || 0) > 0;
  if (hasCritical) process.exit(1);
}

main().catch((err) => {
  console.error(`Error: ${err.message}`);
  process.exit(1);
});
