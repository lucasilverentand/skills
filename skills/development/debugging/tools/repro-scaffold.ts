const args = Bun.argv.slice(2);

const HELP = `
repro-scaffold — Generate a minimal reproduction script from an error report

Usage:
  bun run tools/repro-scaffold.ts <error-file-or-text> [options]

Options:
  --output <file>   Write repro script to file (default: stdout)
  --json            Output as JSON instead of plain text
  --help            Show this help message

Parses an error report (stack trace, error message, or log excerpt) and
generates a minimal TypeScript script that sets up the context for
reproducing the issue.
`.trim();

if (args.includes("--help") || args.length === 0) {
  console.log(HELP);
  process.exit(0);
}

const jsonOutput = args.includes("--json");
const outputIdx = args.indexOf("--output");
const outputFile = outputIdx !== -1 ? args[outputIdx + 1] : null;
const filteredArgs = args.filter(
  (a, i) => !a.startsWith("--") && (outputIdx === -1 || i !== outputIdx + 1)
);

interface ErrorInfo {
  errorType: string;
  errorMessage: string;
  file: string | null;
  line: number | null;
  functionName: string | null;
  imports: string[];
}

function parseErrorReport(text: string): ErrorInfo {
  const info: ErrorInfo = {
    errorType: "Error",
    errorMessage: "",
    file: null,
    line: null,
    functionName: null,
    imports: [],
  };

  const lines = text.split("\n");

  // Extract error type and message
  for (const line of lines) {
    const errorMatch = line.match(/^(\w*Error):\s*(.+)/);
    if (errorMatch) {
      info.errorType = errorMatch[1];
      info.errorMessage = errorMatch[2];
      break;
    }
    // Also try: Error: message
    const simpleMatch = line.match(/^Error:\s*(.+)/);
    if (simpleMatch) {
      info.errorMessage = simpleMatch[1];
      break;
    }
  }

  // Find first project file in stack trace
  for (const line of lines) {
    const frameMatch = line.match(/at\s+(.+?)\s+\((.+):(\d+):(\d+)\)/);
    if (frameMatch) {
      const file = frameMatch[2];
      if (!file.includes("node_modules") && !file.startsWith("node:")) {
        info.functionName = frameMatch[1];
        info.file = file;
        info.line = parseInt(frameMatch[3]);
        break;
      }
    }

    const simpleFrame = line.match(/at\s+(.+):(\d+):(\d+)/);
    if (simpleFrame) {
      const file = simpleFrame[1];
      if (!file.includes("node_modules") && !file.startsWith("node:")) {
        info.file = file;
        info.line = parseInt(simpleFrame[2]);
        break;
      }
    }
  }

  // Detect likely imports from error context
  if (info.errorMessage.includes("fetch") || info.errorMessage.includes("request")) {
    info.imports.push("// May need: import { fetch } from 'node:http'");
  }
  if (info.errorMessage.includes("readFile") || info.errorMessage.includes("ENOENT")) {
    info.imports.push("import { readFile } from 'node:fs/promises'");
  }
  if (info.errorMessage.includes("JSON")) {
    info.imports.push("// JSON parsing involved");
  }

  return info;
}

async function readSourceContext(file: string, line: number): Promise<string[]> {
  try {
    const content = await Bun.file(file).text();
    const lines = content.split("\n");
    const start = Math.max(0, line - 5);
    const end = Math.min(lines.length, line + 5);
    return lines.slice(start, end);
  } catch {
    return [];
  }
}

function generateReproScript(info: ErrorInfo, sourceContext: string[]): string {
  const lines: string[] = [];

  lines.push("#!/usr/bin/env bun");
  lines.push(`// Reproduction script for: ${info.errorType}: ${info.errorMessage}`);
  if (info.file) {
    lines.push(`// Original location: ${info.file}${info.line ? `:${info.line}` : ""}`);
  }
  if (info.functionName) {
    lines.push(`// Function: ${info.functionName}`);
  }
  lines.push(`// Generated by repro-scaffold`);
  lines.push("");

  for (const imp of info.imports) {
    lines.push(imp);
  }
  if (info.imports.length > 0) lines.push("");

  lines.push("// --- Setup ---");
  lines.push("// Add any necessary setup (database connections, test data, etc.)");
  lines.push("");

  if (sourceContext.length > 0) {
    lines.push("// --- Source context from the error location ---");
    for (const ctxLine of sourceContext) {
      lines.push(`// ${ctxLine}`);
    }
    lines.push("");
  }

  lines.push("// --- Reproduction ---");
  lines.push("async function reproduce() {");
  lines.push("  // TODO: Set up the minimal state that triggers the error");
  lines.push("  //");
  lines.push(`  // Expected error: ${info.errorType}: ${info.errorMessage}`);

  if (info.functionName && info.functionName !== "<anonymous>") {
    lines.push(`  //`);
    lines.push(`  // Call ${info.functionName}() with the inputs that trigger the failure`);
  }

  lines.push("  ");
  lines.push("  throw new Error('TODO: Replace with actual reproduction steps');");
  lines.push("}");
  lines.push("");
  lines.push("reproduce()");
  lines.push('  .then(() => console.log("Reproduction complete — error did NOT occur"))');
  lines.push("  .catch((err) => {");
  lines.push('    console.error("Reproduced:", err.message);');
  lines.push("    process.exit(1);");
  lines.push("  });");

  return lines.join("\n");
}

async function main() {
  const input = filteredArgs[0];
  if (!input) {
    console.error("Error: missing error report input (file path or text)");
    process.exit(1);
  }

  let errorText: string;
  const file = Bun.file(input);
  if (await file.exists()) {
    errorText = await file.text();
  } else {
    errorText = filteredArgs.join(" ");
  }

  const info = parseErrorReport(errorText);
  const sourceContext =
    info.file && info.line ? await readSourceContext(info.file, info.line) : [];
  const script = generateReproScript(info, sourceContext);

  if (outputFile) {
    const { resolve } = await import("node:path");
    await Bun.write(resolve(outputFile), script);
    console.log(`Reproduction script written to ${outputFile}`);
  } else if (jsonOutput) {
    console.log(JSON.stringify({ errorInfo: info, script }, null, 2));
  } else {
    console.log(script);
  }
}

main().catch((err) => {
  console.error(`Error: ${err.message}`);
  process.exit(1);
});
